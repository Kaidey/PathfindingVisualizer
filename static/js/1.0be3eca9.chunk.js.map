{"version":3,"sources":["Algorithms/Dijkstra.js"],"names":["Dijkstra","grid","startNode","endNode","this","queue","initqueue","node","find","neigh","row","col","forEach","cell","isWall","push","end","sp","current","path","reverse","visited","n","cost","sort","a","b","indexOf","getNeighbours","aux","pop","next","length","Infinity","endN","computeSP"],"mappings":"+LAAqBA,E,WACnB,WAAYC,EAAMC,EAAWC,GAAU,oBACrCC,KAAKF,UAAYA,EACjBE,KAAKD,QAAUA,EACfC,KAAKC,MAAQD,KAAKE,UAAUL,G,iDAG9B,SAAcM,GAgBZ,MAfmB,CACjBH,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,OAE1DN,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,U,uBAO9D,SAAUT,GACR,IAAMI,EAAQ,GAUd,OARAJ,EAAKW,SAAQ,SAAAF,GACXA,EAAIE,SAAQ,SAAAC,GACLA,EAAKC,QACRT,EAAMU,KAAKF,SAKVR,I,uBAGT,SAAUW,GACR,IAAIC,EAAK,GACLC,EAAUF,EAEd,IAAKA,EAAIG,KACP,MAAO,GAKT,IAFAF,EAAGF,KAAKC,GAEDE,EAAQC,MACbF,EAAGF,KAAKG,EAAQC,MAChBD,EAAUA,EAAQC,KAGpB,OAAOF,EAAGG,Y,iBAGZ,WAAO,IAAD,OACAC,EAAU,GACVlB,EAAUC,KAAKC,MAAMG,MAAK,SAAAc,GAC5B,OAAOA,EAAEX,MAAQ,EAAKR,QAAQQ,KAAOW,EAAEZ,MAAQ,EAAKP,QAAQO,OAE1DQ,EAAUd,KAAKC,MAAMG,MAAK,SAAAc,GAC5B,OAAOA,EAAEX,MAAQ,EAAKT,UAAUS,KAAOW,EAAEZ,MAAQ,EAAKR,UAAUQ,OAUlE,IARAQ,EAAQK,KAAO,EAGfnB,KAAKC,MAAMmB,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEH,KAAOE,EAAEF,SAIiB,IAA9BF,EAAQM,QAAQxB,IAAiB,CACdC,KAAKwB,cAAcV,GAEzBN,SAAQ,SAAAH,GACxB,GAAIA,EAAO,CACT,IAAIoB,EAAMX,EAAQK,KAAO,EACrBd,EAAMc,KAAOM,IACfpB,EAAMc,KAAOM,EACbpB,EAAMU,KAAOD,OAKnBG,EAAQN,KAAKG,GACbd,KAAKC,MAAMyB,MAEX1B,KAAKC,MAAMmB,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEH,KAAOE,EAAEF,QAMpB,IAAMQ,EAAO3B,KAAKC,MAAMD,KAAKC,MAAM2B,OAAS,GAC5C,GAAID,EAAKR,OAASU,IAGhB,MAFAf,EAAUa,EAOd,IAAIG,EAAO9B,KAAKC,MAAMG,MAAK,SAAAqB,GACzB,OAAOA,EAAInB,MAAQ,EAAKP,QAAQO,KAAOmB,EAAIlB,MAAQ,EAAKR,QAAQQ,OASlE,OANKuB,IACHA,EAAOb,EAAQb,MAAK,SAAAqB,GAClB,OAAOA,EAAInB,MAAQ,EAAKP,QAAQO,KAAOmB,EAAIlB,MAAQ,EAAKR,QAAQQ,QAI7D,CAAEM,GAAIb,KAAK+B,UAAUD,GAAOb,QAASA,O","file":"static/js/1.0be3eca9.chunk.js","sourcesContent":["export default class Dijkstra {\r\n  constructor(grid, startNode, endNode) {\r\n    this.startNode = startNode;\r\n    this.endNode = endNode;\r\n    this.queue = this.initqueue(grid);\r\n  }\r\n\r\n  getNeighbours(node) {\r\n    const neighbours = [\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row + 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row - 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col + 1 && neigh.row === node.row;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col - 1 && neigh.row === node.row;\r\n      })\r\n    ];\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  initqueue(grid) {\r\n    const queue = [];\r\n\r\n    grid.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (!cell.isWall) {\r\n          queue.push(cell);\r\n        }\r\n      });\r\n    });\r\n\r\n    return queue;\r\n  }\r\n  //Follow the path property of each visited node starting at the end node to build the full shortest path from start to end (reverse at the end)\r\n  computeSP(end) {\r\n    let sp = [];\r\n    let current = end;\r\n\r\n    if (!end.path) {\r\n      return [];\r\n    }\r\n\r\n    sp.push(end);\r\n\r\n    while (current.path) {\r\n      sp.push(current.path);\r\n      current = current.path;\r\n    }\r\n\r\n    return sp.reverse();\r\n  }\r\n\r\n  run() {\r\n    let visited = [];\r\n    let endNode = this.queue.find(n => {\r\n      return n.col === this.endNode.col && n.row === this.endNode.row;\r\n    });\r\n    let current = this.queue.find(n => {\r\n      return n.col === this.startNode.col && n.row === this.startNode.row;\r\n    });\r\n    current.cost = 0;\r\n\r\n    //Sort so start node is the last node on the list and can be popped\r\n    this.queue.sort((a, b) => {\r\n      return b.cost - a.cost;\r\n    });\r\n\r\n    //While endNode hasn't been visited (Dijkstra adaptation to a 2D grid)\r\n    while (visited.indexOf(endNode) === -1) {\r\n      let currentNeighbours = this.getNeighbours(current);\r\n\r\n      currentNeighbours.forEach(neigh => {\r\n        if (neigh) {\r\n          let aux = current.cost + 1;\r\n          if (neigh.cost > aux) {\r\n            neigh.cost = aux;\r\n            neigh.path = current;\r\n          }\r\n        }\r\n      });\r\n\r\n      visited.push(current);\r\n      this.queue.pop();\r\n      //Sort queue by cost in descending order so the last element is always the next to be visited and thus can be removed (pop()) from the queue easily\r\n      this.queue.sort((a, b) => {\r\n        return b.cost - a.cost;\r\n      });\r\n\r\n      //Safeguard for when the end node is surrounded by walls and thus unreachable\r\n      //In this case all unvisited nodes inside the walled aread will permanently have a cost of Infinity\r\n      //If this is the case, at some point the node with the shortest cost in the queue will be on with a cost of Infinity and the algorithm should stop\r\n      const next = this.queue[this.queue.length - 1];\r\n      if (next.cost !== Infinity) {\r\n        current = next;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    //If the algorithm can't find a path to the end node it won't be added to the visited list\r\n    let endN = this.queue.find(aux => {\r\n      return aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n    });\r\n\r\n    if (!endN) {\r\n      endN = visited.find(aux => {\r\n        return aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n      });\r\n    }\r\n\r\n    return { sp: this.computeSP(endN), visited: visited };\r\n  }\r\n}\r\n"],"sourceRoot":""}