{"version":3,"sources":["Algorithms/Dijkstra.js"],"names":["Dijkstra","grid","startNode","endNode","this","queue","initqueue","node","find","neigh","row","col","forEach","cell","isWall","push","end","sp","current","path","reverse","visited","startIdx","indexOf","cost","sort","a","b","getNeighbours","aux","pop","length","endN","computeSP"],"mappings":"+LAAqBA,E,WACnB,WAAYC,EAAMC,EAAWC,GAAU,oBACrCC,KAAKF,UAAYA,EACjBE,KAAKD,QAAUA,EACfC,KAAKC,MAAQD,KAAKE,UAAUL,G,0DAGhBM,GAgBZ,MAfmB,CACjBH,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,OAE1DN,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,U,gCAOpDT,GACR,IAAMI,EAAQ,GAUd,OARAJ,EAAKW,SAAQ,SAAAF,GACXA,EAAIE,SAAQ,SAAAC,GACLA,EAAKC,QACRT,EAAMU,KAAKF,SAKVR,I,gCAGCW,GACR,IAAIC,EAAK,GACLC,EAAUF,EAId,IAFAC,EAAGF,KAAKC,GAEDE,EAAQC,MACbF,EAAGF,KAAKG,EAAQC,MAChBD,EAAUA,EAAQC,KAGpB,OAAOF,EAAGG,Y,4BAGL,IAAD,OACAC,EAAU,GACVC,EAAWlB,KAAKC,MAAMkB,QAAQnB,KAAKF,WACnCgB,EAAUd,KAAKC,MAAMiB,GASzB,IARAJ,EAAQM,KAAO,EAGfpB,KAAKC,MAAMoB,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEH,KAAOE,EAAEF,SAIsB,IAAnCH,EAAQE,QAAQnB,KAAKD,UAAiB,CACnBC,KAAKwB,cAAcV,GAEzBN,SAAQ,SAAAH,GACxB,GAAIA,EAAO,CACT,IAAIoB,EAAMX,EAAQM,KAAO,EACrBf,EAAMe,KAAOK,IACfpB,EAAMe,KAAOK,EACbpB,EAAMU,KAAOD,OAKnBG,EAAQN,KAAKG,GACbd,KAAKC,MAAMyB,MAEX1B,KAAKC,MAAMoB,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEH,KAAOE,EAAEF,QAGpBN,EAAUd,KAAKC,MAAMD,KAAKC,MAAM0B,OAAS,GAG3C,IAAIC,EAAOX,EAAQb,MAAK,SAAAqB,GACtB,OAAOA,EAAInB,MAAQ,EAAKP,QAAQO,KAAOmB,EAAIlB,MAAQ,EAAKR,QAAQQ,OAGlE,MAAO,CAAEM,GAAIb,KAAK6B,UAAUD,GAAOX,QAASA,O","file":"static/js/1.0204c1d6.chunk.js","sourcesContent":["export default class Dijkstra {\r\n  constructor(grid, startNode, endNode) {\r\n    this.startNode = startNode;\r\n    this.endNode = endNode;\r\n    this.queue = this.initqueue(grid);\r\n  }\r\n\r\n  getNeighbours(node) {\r\n    const neighbours = [\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row + 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row - 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col + 1 && neigh.row === node.row;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col - 1 && neigh.row === node.row;\r\n      })\r\n    ];\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  initqueue(grid) {\r\n    const queue = [];\r\n\r\n    grid.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (!cell.isWall) {\r\n          queue.push(cell);\r\n        }\r\n      });\r\n    });\r\n\r\n    return queue;\r\n  }\r\n  //Follow the path property of each visited node starting at the end node to build the full shortest path from start to end (reverse at the end)\r\n  computeSP(end) {\r\n    let sp = [];\r\n    let current = end;\r\n\r\n    sp.push(end);\r\n\r\n    while (current.path) {\r\n      sp.push(current.path);\r\n      current = current.path;\r\n    }\r\n\r\n    return sp.reverse();\r\n  }\r\n\r\n  run() {\r\n    let visited = [];\r\n    let startIdx = this.queue.indexOf(this.startNode);\r\n    let current = this.queue[startIdx];\r\n    current.cost = 0;\r\n\r\n    //Sort so start node is the last node on the list and can be popped\r\n    this.queue.sort((a, b) => {\r\n      return b.cost - a.cost;\r\n    });\r\n\r\n    //While endNode hasn't been visited (Dijkstra adaptation to a 2D grid)\r\n    while (visited.indexOf(this.endNode) === -1) {\r\n      let currentNeighbours = this.getNeighbours(current);\r\n\r\n      currentNeighbours.forEach(neigh => {\r\n        if (neigh) {\r\n          let aux = current.cost + 1;\r\n          if (neigh.cost > aux) {\r\n            neigh.cost = aux;\r\n            neigh.path = current;\r\n          }\r\n        }\r\n      });\r\n\r\n      visited.push(current);\r\n      this.queue.pop();\r\n      //Sort queue by cost in descending order so the last element is always the next to be visited and thus can be removed (pop()) from the queue easily\r\n      this.queue.sort((a, b) => {\r\n        return b.cost - a.cost;\r\n      });\r\n\r\n      current = this.queue[this.queue.length - 1];\r\n    }\r\n\r\n    let endN = visited.find(aux => {\r\n      return aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n    });\r\n\r\n    return { sp: this.computeSP(endN), visited: visited };\r\n  }\r\n}\r\n"],"sourceRoot":""}