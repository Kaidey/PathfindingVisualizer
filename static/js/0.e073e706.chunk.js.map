{"version":3,"sources":["Algorithms/AStar.js"],"names":["Dijkstra","grid","startNode","endNode","this","queue","initqueue","node","find","neigh","row","col","forEach","cell","isWall","distance","Infinity","push","xCoords","Math","pow","yCoords","sqrt","end","sp","current","path","reverse","visited","startIdx","indexOf","console","log","cost","sort","a","b","getNeighbours","aux","calcEuclideanDistance","pop","length","endN","computeSP"],"mappings":"+LAAqBA,E,WACnB,WAAYC,EAAMC,EAAWC,GAAU,oBACrCC,KAAKF,UAAYA,EACjBE,KAAKD,QAAUA,EACfC,KAAKC,MAAQD,KAAKE,UAAUL,G,0DAGhBM,GAgBZ,MAfmB,CACjBH,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,OAE1DN,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,U,gCAOpDT,GACR,IAAMI,EAAQ,GAWd,OATAJ,EAAKW,SAAQ,SAAAF,GACXA,EAAIE,SAAQ,SAAAC,GACLA,EAAKC,SACRD,EAAKE,SAAWC,IAChBX,EAAMY,KAAKJ,UAKVR,I,4CAGaE,GACpB,IAAMW,EAAUC,KAAKC,IAAIhB,KAAKD,QAAQQ,IAAMJ,EAAKI,IAAK,GAChDU,EAAUF,KAAKC,IAAIhB,KAAKD,QAAQO,IAAMH,EAAKG,IAAK,GAEtD,OAAOS,KAAKG,KAAKJ,EAAUG,K,gCAInBE,GACR,IAAIC,EAAK,GACLC,EAAUF,EAId,IAFAC,EAAGP,KAAKM,GAEDE,EAAQC,MACbF,EAAGP,KAAKQ,EAAQC,MAChBD,EAAUA,EAAQC,KAGpB,OAAOF,EAAGG,Y,4BAGL,IAAD,OACAC,EAAU,GACVC,EAAWzB,KAAKC,MAAMyB,QAAQ1B,KAAKF,WACvC6B,QAAQC,IAAI5B,KAAKC,OACjB,IAAIoB,EAAUrB,KAAKC,MAAMwB,GASzB,IARAJ,EAAQQ,KAAO,EAGf7B,KAAKC,MAAM6B,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEH,KAAOE,EAAEF,SAIsB,IAAnCL,EAAQE,QAAQ1B,KAAKD,UAAiB,CACnBC,KAAKiC,cAAcZ,GAEzBb,SAAQ,SAAAH,GACxB,GAAIA,EAAO,CACT,IAAI6B,EAAMb,EAAQQ,KAAO,EACrBxB,EAAMwB,KAAOK,IACf7B,EAAMwB,KAAOK,EACb7B,EAAMiB,KAAOD,EACbhB,EAAMM,SAAW,EAAKwB,sBAAsB9B,GAASA,EAAMwB,UAKjEL,EAAQX,KAAKQ,GACbrB,KAAKC,MAAMmC,MAEXpC,KAAKC,MAAM6B,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAErB,SAAWoB,EAAEpB,YAGxBU,EAAUrB,KAAKC,MAAMD,KAAKC,MAAMoC,OAAS,GAG3C,IAAIC,EAAOd,EAAQpB,MAAK,SAAA8B,GACtB,OAAOA,EAAI5B,MAAQ,EAAKP,QAAQO,KAAO4B,EAAI3B,MAAQ,EAAKR,QAAQQ,OAGlE,MAAO,CAAEa,GAAIpB,KAAKuC,UAAUD,GAAOd,QAASA,O","file":"static/js/0.e073e706.chunk.js","sourcesContent":["export default class Dijkstra {\r\n  constructor(grid, startNode, endNode) {\r\n    this.startNode = startNode;\r\n    this.endNode = endNode;\r\n    this.queue = this.initqueue(grid);\r\n  }\r\n\r\n  getNeighbours(node) {\r\n    const neighbours = [\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row + 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row - 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col + 1 && neigh.row === node.row;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col - 1 && neigh.row === node.row;\r\n      })\r\n    ];\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  initqueue(grid) {\r\n    const queue = [];\r\n\r\n    grid.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (!cell.isWall) {\r\n          cell.distance = Infinity;\r\n          queue.push(cell);\r\n        }\r\n      });\r\n    });\r\n\r\n    return queue;\r\n  }\r\n\r\n  calcEuclideanDistance(node) {\r\n    const xCoords = Math.pow(this.endNode.col - node.col, 2);\r\n    const yCoords = Math.pow(this.endNode.row - node.row, 2);\r\n\r\n    return Math.sqrt(xCoords + yCoords);\r\n  }\r\n\r\n  //Follow the path property of each visited node starting at the end node to build the full shortest path from start to end (reverse at the end)\r\n  computeSP(end) {\r\n    let sp = [];\r\n    let current = end;\r\n\r\n    sp.push(end);\r\n\r\n    while (current.path) {\r\n      sp.push(current.path);\r\n      current = current.path;\r\n    }\r\n\r\n    return sp.reverse();\r\n  }\r\n\r\n  run() {\r\n    let visited = [];\r\n    let startIdx = this.queue.indexOf(this.startNode);\r\n    console.log(this.queue);\r\n    let current = this.queue[startIdx];\r\n    current.cost = 0;\r\n\r\n    //Sort so start node is the last node on the list and can be popped\r\n    this.queue.sort((a, b) => {\r\n      return b.cost - a.cost;\r\n    });\r\n\r\n    //While endNode hasn't been visited (Dijkstra adaptation to a 2D grid)\r\n    while (visited.indexOf(this.endNode) === -1) {\r\n      let currentNeighbours = this.getNeighbours(current);\r\n\r\n      currentNeighbours.forEach(neigh => {\r\n        if (neigh) {\r\n          let aux = current.cost + 1;\r\n          if (neigh.cost > aux) {\r\n            neigh.cost = aux;\r\n            neigh.path = current;\r\n            neigh.distance = this.calcEuclideanDistance(neigh) + neigh.cost;\r\n          }\r\n        }\r\n      });\r\n\r\n      visited.push(current);\r\n      this.queue.pop();\r\n      //Sort queue by distance in descending order so the last element is always the next to be visited and thus can be removed (pop()) from the queue easily\r\n      this.queue.sort((a, b) => {\r\n        return b.distance - a.distance;\r\n      });\r\n\r\n      current = this.queue[this.queue.length - 1];\r\n    }\r\n\r\n    let endN = visited.find(aux => {\r\n      return aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n    });\r\n\r\n    return { sp: this.computeSP(endN), visited: visited };\r\n  }\r\n}\r\n"],"sourceRoot":""}