{"version":3,"sources":["Algorithms/AStar.js"],"names":["AStar","grid","startNode","endNode","this","queue","initqueue","node","find","neigh","row","col","forEach","cell","isWall","distance","Infinity","push","xCoords","Math","pow","yCoords","sqrt","end","sp","current","path","reverse","visited","n","cost","sort","a","b","indexOf","getNeighbours","aux","calcEuclideanDistance","pop","next","length","endN","computeSP"],"mappings":"+LAAqBA,E,WACpB,WAAYC,EAAMC,EAAWC,GAAU,oBACtCC,KAAKF,UAAYA,EACjBE,KAAKD,QAAUA,EACfC,KAAKC,MAAQD,KAAKE,UAAUL,G,iDAG7B,SAAcM,GAgBb,MAfmB,CAClBH,KAAKC,MAAMG,MAAK,SAACC,GAChB,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAEzDP,KAAKC,MAAMG,MAAK,SAACC,GAChB,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAEzDP,KAAKC,MAAMG,MAAK,SAACC,GAChB,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,OAEzDN,KAAKC,MAAMG,MAAK,SAACC,GAChB,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,U,uBAO3D,SAAUT,GACT,IAAMI,EAAQ,GAWd,OATAJ,EAAKW,SAAQ,SAACF,GACbA,EAAIE,SAAQ,SAACC,GACPA,EAAKC,SACTD,EAAKE,SAAWC,IAChBX,EAAMY,KAAKJ,UAKPR,I,mCAGR,SAAsBE,GACrB,IAAMW,EAAUC,KAAKC,IAAIhB,KAAKD,QAAQQ,IAAMJ,EAAKI,IAAK,GAChDU,EAAUF,KAAKC,IAAIhB,KAAKD,QAAQO,IAAMH,EAAKG,IAAK,GAEtD,OAAOS,KAAKG,KAAKJ,EAAUG,K,uBAI5B,SAAUE,GACT,IAAIC,EAAK,GACLC,EAAUF,EAEd,IAAKA,EAAIG,KACR,MAAO,GAKR,IAFAF,EAAGP,KAAKM,GAEDE,EAAQC,MACdF,EAAGP,KAAKQ,EAAQC,MAChBD,EAAUA,EAAQC,KAGnB,OAAOF,EAAGG,Y,iBAGX,WAAO,IAAD,OACDC,EAAU,GACVzB,EAAUC,KAAKC,MAAMG,MAAK,SAACqB,GAC9B,OAAOA,EAAElB,MAAQ,EAAKR,QAAQQ,KAAOkB,EAAEnB,MAAQ,EAAKP,QAAQO,OAEzDe,EAAUrB,KAAKC,MAAMG,MAAK,SAACqB,GAC9B,OAAOA,EAAElB,MAAQ,EAAKT,UAAUS,KAAOkB,EAAEnB,MAAQ,EAAKR,UAAUQ,OAUjE,IARAe,EAAQK,KAAO,EAGf1B,KAAKC,MAAM0B,MAAK,SAACC,EAAGC,GACnB,OAAOA,EAAEH,KAAOE,EAAEF,SAIkB,IAA9BF,EAAQM,QAAQ/B,IAAiB,CACfC,KAAK+B,cAAcV,GAEzBb,SAAQ,SAACH,GAC1B,GAAIA,EAAO,CACV,IAAI2B,EAAMX,EAAQK,KAAO,EACrBrB,EAAMqB,KAAOM,IAChB3B,EAAMqB,KAAOM,EACb3B,EAAMiB,KAAOD,EACbhB,EAAMM,SAAW,EAAKsB,sBAAsB5B,GAASA,EAAMqB,UAK9DF,EAAQX,KAAKQ,GACbrB,KAAKC,MAAMiC,MAEXlC,KAAKC,MAAM0B,MAAK,SAACC,EAAGC,GACnB,OAAOA,EAAElB,SAAWiB,EAAEjB,YAMvB,IAAMwB,EAAOnC,KAAKC,MAAMD,KAAKC,MAAMmC,OAAS,GAC5C,GAAID,EAAKT,OAASd,IAGjB,MAFAS,EAAUc,EAOZ,IAAIE,EAAOrC,KAAKC,MAAMG,MAAK,SAAC4B,GAC3B,OAAOA,EAAI1B,MAAQ,EAAKP,QAAQO,KAAO0B,EAAIzB,MAAQ,EAAKR,QAAQQ,OASjE,OANK8B,IACJA,EAAOb,EAAQpB,MAAK,SAAC4B,GACpB,OAAOA,EAAI1B,MAAQ,EAAKP,QAAQO,KAAO0B,EAAIzB,MAAQ,EAAKR,QAAQQ,QAI3D,CAAEa,GAAIpB,KAAKsC,UAAUD,GAAOb,QAASA,O","file":"static/js/0.d957db52.chunk.js","sourcesContent":["export default class AStar {\r\n\tconstructor(grid, startNode, endNode) {\r\n\t\tthis.startNode = startNode;\r\n\t\tthis.endNode = endNode;\r\n\t\tthis.queue = this.initqueue(grid);\r\n\t}\r\n\r\n\tgetNeighbours(node) {\r\n\t\tconst neighbours = [\r\n\t\t\tthis.queue.find((neigh) => {\r\n\t\t\t\treturn neigh.row === node.row + 1 && neigh.col === node.col;\r\n\t\t\t}),\r\n\t\t\tthis.queue.find((neigh) => {\r\n\t\t\t\treturn neigh.row === node.row - 1 && neigh.col === node.col;\r\n\t\t\t}),\r\n\t\t\tthis.queue.find((neigh) => {\r\n\t\t\t\treturn neigh.col === node.col + 1 && neigh.row === node.row;\r\n\t\t\t}),\r\n\t\t\tthis.queue.find((neigh) => {\r\n\t\t\t\treturn neigh.col === node.col - 1 && neigh.row === node.row;\r\n\t\t\t}),\r\n\t\t];\r\n\r\n\t\treturn neighbours;\r\n\t}\r\n\r\n\tinitqueue(grid) {\r\n\t\tconst queue = [];\r\n\r\n\t\tgrid.forEach((row) => {\r\n\t\t\trow.forEach((cell) => {\r\n\t\t\t\tif (!cell.isWall) {\r\n\t\t\t\t\tcell.distance = Infinity;\r\n\t\t\t\t\tqueue.push(cell);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn queue;\r\n\t}\r\n\r\n\tcalcEuclideanDistance(node) {\r\n\t\tconst xCoords = Math.pow(this.endNode.col - node.col, 2);\r\n\t\tconst yCoords = Math.pow(this.endNode.row - node.row, 2);\r\n\r\n\t\treturn Math.sqrt(xCoords + yCoords);\r\n\t}\r\n\r\n\t//Follow the path property of each visited node starting at the end node to build the full shortest path from start to end (reverse at the end)\r\n\tcomputeSP(end) {\r\n\t\tlet sp = [];\r\n\t\tlet current = end;\r\n\r\n\t\tif (!end.path) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tsp.push(end);\r\n\r\n\t\twhile (current.path) {\r\n\t\t\tsp.push(current.path);\r\n\t\t\tcurrent = current.path;\r\n\t\t}\r\n\r\n\t\treturn sp.reverse();\r\n\t}\r\n\r\n\trun() {\r\n\t\tlet visited = [];\r\n\t\tlet endNode = this.queue.find((n) => {\r\n\t\t\treturn n.col === this.endNode.col && n.row === this.endNode.row;\r\n\t\t});\r\n\t\tlet current = this.queue.find((n) => {\r\n\t\t\treturn n.col === this.startNode.col && n.row === this.startNode.row;\r\n\t\t});\r\n\t\tcurrent.cost = 0;\r\n\r\n\t\t//Sort so start node is the last node on the list and can be popped\r\n\t\tthis.queue.sort((a, b) => {\r\n\t\t\treturn b.cost - a.cost;\r\n\t\t});\r\n\r\n\t\t//While endNode hasn't been visited (Dijkstra adaptation to a 2D grid)\r\n\t\twhile (visited.indexOf(endNode) === -1) {\r\n\t\t\tlet currentNeighbours = this.getNeighbours(current);\r\n\r\n\t\t\tcurrentNeighbours.forEach((neigh) => {\r\n\t\t\t\tif (neigh) {\r\n\t\t\t\t\tlet aux = current.cost + 1;\r\n\t\t\t\t\tif (neigh.cost > aux) {\r\n\t\t\t\t\t\tneigh.cost = aux;\r\n\t\t\t\t\t\tneigh.path = current;\r\n\t\t\t\t\t\tneigh.distance = this.calcEuclideanDistance(neigh) + neigh.cost;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tvisited.push(current);\r\n\t\t\tthis.queue.pop();\r\n\t\t\t//Sort queue by distance in descending order so the last element is always the next to be visited and thus can be removed (pop()) from the queue easily\r\n\t\t\tthis.queue.sort((a, b) => {\r\n\t\t\t\treturn b.distance - a.distance;\r\n\t\t\t});\r\n\r\n\t\t\t//Safeguard for when the end node is surrounded by walls and thus unreachable\r\n\t\t\t//In this case all unvisited nodes inside the walled aread will permanently have a cost of Infinity\r\n\t\t\t//If this is the case, at some point the node with the shortest cost in the queue will be on with a cost of Infinity and the algorithm should stop\r\n\t\t\tconst next = this.queue[this.queue.length - 1];\r\n\t\t\tif (next.cost !== Infinity) {\r\n\t\t\t\tcurrent = next;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//If the algorithm can't find a path to the end node it won't be added to the visited list\r\n\t\tlet endN = this.queue.find((aux) => {\r\n\t\t\treturn aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n\t\t});\r\n\r\n\t\tif (!endN) {\r\n\t\t\tendN = visited.find((aux) => {\r\n\t\t\t\treturn aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn { sp: this.computeSP(endN), visited: visited };\r\n\t}\r\n}\r\n"],"sourceRoot":""}