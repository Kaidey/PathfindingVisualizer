{"version":3,"sources":["Algorithms/AStar.js"],"names":["Dijkstra","grid","startNode","endNode","this","queue","initqueue","node","find","neigh","row","col","forEach","cell","isWall","distance","Infinity","push","xCoords","Math","pow","yCoords","sqrt","end","sp","current","console","log","path","reverse","visited","n","cost","sort","a","b","indexOf","getNeighbours","aux","calcEuclideanDistance","pop","next","length","endN","computeSP"],"mappings":"+LAAqBA,E,WACnB,WAAYC,EAAMC,EAAWC,GAAU,oBACrCC,KAAKF,UAAYA,EACjBE,KAAKD,QAAUA,EACfC,KAAKC,MAAQD,KAAKE,UAAUL,G,0DAGhBM,GAgBZ,MAfmB,CACjBH,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAMC,MAAQH,EAAKG,IAAM,GAAKD,EAAME,MAAQJ,EAAKI,OAE1DP,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,OAE1DN,KAAKC,MAAMG,MAAK,SAAAC,GACd,OAAOA,EAAME,MAAQJ,EAAKI,IAAM,GAAKF,EAAMC,MAAQH,EAAKG,U,gCAOpDT,GACR,IAAMI,EAAQ,GAWd,OATAJ,EAAKW,SAAQ,SAAAF,GACXA,EAAIE,SAAQ,SAAAC,GACLA,EAAKC,SACRD,EAAKE,SAAWC,IAChBX,EAAMY,KAAKJ,UAKVR,I,4CAGaE,GACpB,IAAMW,EAAUC,KAAKC,IAAIhB,KAAKD,QAAQQ,IAAMJ,EAAKI,IAAK,GAChDU,EAAUF,KAAKC,IAAIhB,KAAKD,QAAQO,IAAMH,EAAKG,IAAK,GAEtD,OAAOS,KAAKG,KAAKJ,EAAUG,K,gCAInBE,GACR,IAAIC,EAAK,GACLC,EAAUF,EAId,GAFAG,QAAQC,IAAIJ,IAEPA,EAAIK,KACP,MAAO,GAKT,IAFAJ,EAAGP,KAAKM,GAEDE,EAAQG,MACbJ,EAAGP,KAAKQ,EAAQG,MAChBH,EAAUA,EAAQG,KAGpB,OAAOJ,EAAGK,Y,4BAGL,IAAD,OACAC,EAAU,GACV3B,EAAUC,KAAKC,MAAMG,MAAK,SAAAuB,GAC5B,OAAOA,EAAEpB,MAAQ,EAAKR,QAAQQ,KAAOoB,EAAErB,MAAQ,EAAKP,QAAQO,OAE1De,EAAUrB,KAAKC,MAAMG,MAAK,SAAAuB,GAC5B,OAAOA,EAAEpB,MAAQ,EAAKT,UAAUS,KAAOoB,EAAErB,MAAQ,EAAKR,UAAUQ,OAUlE,IARAe,EAAQO,KAAO,EAGf5B,KAAKC,MAAM4B,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEH,KAAOE,EAAEF,SAIiB,IAA9BF,EAAQM,QAAQjC,IAAiB,CACdC,KAAKiC,cAAcZ,GAEzBb,SAAQ,SAAAH,GACxB,GAAIA,EAAO,CACT,IAAI6B,EAAMb,EAAQO,KAAO,EACrBvB,EAAMuB,KAAOM,IACf7B,EAAMuB,KAAOM,EACb7B,EAAMmB,KAAOH,EACbhB,EAAMM,SAAW,EAAKwB,sBAAsB9B,GAASA,EAAMuB,UAKjEF,EAAQb,KAAKQ,GACbrB,KAAKC,MAAMmC,MAEXpC,KAAKC,MAAM4B,MAAK,SAACC,EAAGC,GAClB,OAAOA,EAAEpB,SAAWmB,EAAEnB,YAMxB,IAAM0B,EAAOrC,KAAKC,MAAMD,KAAKC,MAAMqC,OAAS,GAC5C,GAAID,EAAKT,OAAShB,IAGhB,MAFAS,EAAUgB,EAOd,IAAIE,EAAOvC,KAAKC,MAAMG,MAAK,SAAA8B,GACzB,OAAOA,EAAI5B,MAAQ,EAAKP,QAAQO,KAAO4B,EAAI3B,MAAQ,EAAKR,QAAQQ,OASlE,OANKgC,IACHA,EAAOb,EAAQtB,MAAK,SAAA8B,GAClB,OAAOA,EAAI5B,MAAQ,EAAKP,QAAQO,KAAO4B,EAAI3B,MAAQ,EAAKR,QAAQQ,QAI7D,CAAEa,GAAIpB,KAAKwC,UAAUD,GAAOb,QAASA,O","file":"static/js/0.8bbff378.chunk.js","sourcesContent":["export default class Dijkstra {\r\n  constructor(grid, startNode, endNode) {\r\n    this.startNode = startNode;\r\n    this.endNode = endNode;\r\n    this.queue = this.initqueue(grid);\r\n  }\r\n\r\n  getNeighbours(node) {\r\n    const neighbours = [\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row + 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.row === node.row - 1 && neigh.col === node.col;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col + 1 && neigh.row === node.row;\r\n      }),\r\n      this.queue.find(neigh => {\r\n        return neigh.col === node.col - 1 && neigh.row === node.row;\r\n      })\r\n    ];\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  initqueue(grid) {\r\n    const queue = [];\r\n\r\n    grid.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (!cell.isWall) {\r\n          cell.distance = Infinity;\r\n          queue.push(cell);\r\n        }\r\n      });\r\n    });\r\n\r\n    return queue;\r\n  }\r\n\r\n  calcEuclideanDistance(node) {\r\n    const xCoords = Math.pow(this.endNode.col - node.col, 2);\r\n    const yCoords = Math.pow(this.endNode.row - node.row, 2);\r\n\r\n    return Math.sqrt(xCoords + yCoords);\r\n  }\r\n\r\n  //Follow the path property of each visited node starting at the end node to build the full shortest path from start to end (reverse at the end)\r\n  computeSP(end) {\r\n    let sp = [];\r\n    let current = end;\r\n\r\n    console.log(end);\r\n\r\n    if (!end.path) {\r\n      return [];\r\n    }\r\n\r\n    sp.push(end);\r\n\r\n    while (current.path) {\r\n      sp.push(current.path);\r\n      current = current.path;\r\n    }\r\n\r\n    return sp.reverse();\r\n  }\r\n\r\n  run() {\r\n    let visited = [];\r\n    let endNode = this.queue.find(n => {\r\n      return n.col === this.endNode.col && n.row === this.endNode.row;\r\n    });\r\n    let current = this.queue.find(n => {\r\n      return n.col === this.startNode.col && n.row === this.startNode.row;\r\n    });\r\n    current.cost = 0;\r\n\r\n    //Sort so start node is the last node on the list and can be popped\r\n    this.queue.sort((a, b) => {\r\n      return b.cost - a.cost;\r\n    });\r\n\r\n    //While endNode hasn't been visited (Dijkstra adaptation to a 2D grid)\r\n    while (visited.indexOf(endNode) === -1) {\r\n      let currentNeighbours = this.getNeighbours(current);\r\n\r\n      currentNeighbours.forEach(neigh => {\r\n        if (neigh) {\r\n          let aux = current.cost + 1;\r\n          if (neigh.cost > aux) {\r\n            neigh.cost = aux;\r\n            neigh.path = current;\r\n            neigh.distance = this.calcEuclideanDistance(neigh) + neigh.cost;\r\n          }\r\n        }\r\n      });\r\n\r\n      visited.push(current);\r\n      this.queue.pop();\r\n      //Sort queue by distance in descending order so the last element is always the next to be visited and thus can be removed (pop()) from the queue easily\r\n      this.queue.sort((a, b) => {\r\n        return b.distance - a.distance;\r\n      });\r\n\r\n      //Safeguard for when the end node is surrounded by walls and thus unreachable\r\n      //In this case all unvisited nodes inside the walled aread will permanently have a cost of Infinity\r\n      //If this is the case, at some point the node with the shortest cost in the queue will be on with a cost of Infinity and the algorithm should stop\r\n      const next = this.queue[this.queue.length - 1];\r\n      if (next.cost !== Infinity) {\r\n        current = next;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    //If the algorithm can't find a path to the end node it won't be added to the visited list\r\n    let endN = this.queue.find(aux => {\r\n      return aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n    });\r\n\r\n    if (!endN) {\r\n      endN = visited.find(aux => {\r\n        return aux.row === this.endNode.row && aux.col === this.endNode.col;\r\n      });\r\n    }\r\n\r\n    return { sp: this.computeSP(endN), visited: visited };\r\n  }\r\n}\r\n"],"sourceRoot":""}